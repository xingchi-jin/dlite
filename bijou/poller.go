package bijou

import (
	"context"
	"sync"
	"time"

	"github.com/wings-software/dlite/client"
	"github.com/wings-software/dlite/router"
	"github.com/wings-software/dlite/bijou/handlers"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

var (
	taskEventsTimeout = 30 * time.Second
)

type FilterFn func(*client.RunnerEvent) bool

type EventsServer struct {
	AccountID     string
	AccountSecret string
	Name          string   // name of the runner
	Tags          []string // list of tags that the runner accepts
	Client        client.Client
	handlers      *handlers.HandlersMapper
	//Router        router.Router
	Filter        FilterFn
	// The Harness manager allows two task acquire calls with the same delegate ID to go through (by design).
	// We need to make sure two different threads do not acquire the same task.
	// This map makes sure Acquire() is called only once per task ID. The mapping is removed once the status
	// for the task has been sent.
	m sync.Map
}

type DelegateInfo struct {
	Host string
	IP   string
	ID   string
	Name string
}

func New(accountID, accountSecret, name string, tags []string, c client.Client, r router.Router) *EventsServer {
	return &EventsServer{
		AccountID:     accountID,
		AccountSecret: accountSecret,
		Tags:          tags,
		Name:          name,
		Client:        c,
		//Router:        r,
		m:             sync.Map{},
	}
}

func (p *EventsServer) SetFilter(filter FilterFn) {
	p.Filter = filter
}


// Poll continually asks the task server for tasks to execute. It executes the tasks by routing
// them to the correct handler and updating the status of the task to the server.
// id is the delegate instance ID. It's generated by the server on registration.
func (p *EventsServer) PollRunnerEvents(ctx context.Context, n int, id string, interval time.Duration) error {
	var wg sync.WaitGroup
	events := make(chan *client.RunnerEvent, n)
	// Task event poller
	go func() {
		pollTimer := time.NewTimer(interval)
		for {
			pollTimer.Reset(interval)
			select {
			case <-ctx.Done():
				logrus.Error("context canceled")
				return
			case <-pollTimer.C:
				taskEventsCtx, cancelFn := context.WithTimeout(ctx, taskEventsTimeout)
				tasks, err := p.Client.GetRunnerEvents(taskEventsCtx, id)
				if err != nil {
					logrus.WithError(err).Errorf("could not query for task events")
				}
				cancelFn()

				for _, e := range tasks.RunnerEvents {
					events <- e
				}

				// Search for a task event matching the filter
				// for _, ev := range tasks.RunnerEvents {
				// 	if p.Filter == nil || p.Filter(ev) {
				// 		logrus.WithField("task_id", ev.TaskID).Info("trying to acquire task")
				// 		events <- ev
				// 	}
				// }
			}
		}
	}()
	// Task event executor
	for i := 0; i < n; i++ {
		wg.Add(1)
		go func(i int) {
			for {
				select {
				case <-ctx.Done():
					wg.Done()
					return
				case task := <-events:
					logrus.Info(*task)
					err := p.executeRunnerEvent(ctx, id, *task, i)
					if err != nil {
						logrus.WithError(err).WithField("task_id", task.TaskID).Errorf("[Thread %d]: delegate [%s] could not perform task execution", i, id)
					}
				}
			}
		}(i)
	}
	logrus.Infof("initialized %d threads successfully and starting polling for tasks", n)
	wg.Wait()
	return nil
}

// execute tries to acquire the task and executes the handler for it
func (p *EventsServer) executeRunnerEvent(ctx context.Context, delegateID string, rv client.RunnerEvent, i int) error {
	taskID := rv.TaskID
	if _, loaded := p.m.LoadOrStore(taskID, true); loaded {
		return nil
	}
	defer p.m.Delete(taskID)
	payloads, err := p.Client.GetExecutionPayload(ctx, delegateID, taskID)
	logrus.Info(payloads)
	if err != nil {
		return errors.Wrap(err, "failed to get payload")
	}
	// bb, err := pb.Marshal(payload)
	// if err != nil {
	// 	return errors.Wrap(err, "failed to encode task")
	// }
	// buf := bytes.NewBuffer(bb)
	// logrus.Infof("[Thread %d]: successfully get payload taskID: %s of type: %s", i, taskID, payload.Task[0].EventType)

	// // TODO: Discuss possible better ways to forward the HTTP response to the task for processing
	// // For now, keeping the handler interface consistent with the HTTP handler to allow for possible
	// // extension in the future with CGI, etc.
	// req, err := http.NewRequestWithContext(ctx, "POST", "/", buf)
	// if err != nil {
	// 	return err
	// }

	// task := payload.Task[0]
	for i, payload := range payloads.Task {
		logrus.WithField("ProcessingEventCount", i).Info("")
		if handler := p.handlers.Get(payload.EventType); handler != nil {
			handler.Handle(ctx, payload.RunnerType, payload)
		} else {
			logrus.WithField("EventType", payload.EventType).Error("Cannot find handler for eventType")
		}
	}

	// writer := NewResponseWriter()
	// p.Router.Route(task.EventType).ServeHTTP(writer, req)
	// taskResponse := &client.TaskResponse{
	// 	ID:   task.GetId(),
	// 	Data: writer.buf.Bytes(),
	// 	Code: "OK",
	// 	Type: "CI_LE_STATUS",
	// }
	// err = p.Client.SendStatus(context.Background(), delegateID, taskID, taskResponse)
	// if err != nil {
	// 	return errors.Wrap(err, "failed to send step status")
	// }
	logrus.Infof("[Thread %d]: successfully completed task execution of taskID: %s of type: %s", i, taskID, task.EventType)
	return nil
}
